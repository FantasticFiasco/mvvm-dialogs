<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--------------------------------------------------------------------------->  
<!--                           INTRODUCTION                                

 The Code Project article submission template (HTML version)

Using this template will help us post your article sooner. To use, just 
follow the 3 easy steps below:
 
     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets. 

-->  
<!--------------------------------------------------------------------------->  
<!--                        IGNORE THIS SECTION                            -->
<html>
<head>
<title>The Code Project</title>
<Style>
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
</style>
<link rel="stylesheet" type="text/css" href="http://www.codeproject.com/App_Themes/NetCommunity/CodeProject.css">
</head>
<body bgcolor="#FFFFFF" color=#000000>
<!--------------------------------------------------------------------------->  


<!-------------------------------     STEP 1      --------------------------->
<!--  Fill in the details (CodeProject will reformat this section for you) -->

<pre>
Title:       Showing dialogs when using MVVM pattern
Author:      Mattias Kindborg
Email:       mattias.kindborg@gmail.com
Member ID:   1900638
Language:    C# 3.0
Platform:    .NET 3.5
Technology:  WPF, XAML
Level:       Intermediate
Description: One solution on how to solve the problem of opening dialogs from a
             ViewModel when using the MVVM pattern.
Section      Languages
SubSection   C#
License:     <a href="http://www.codeproject.com/info/cpol10.aspx">CPOL</a>
</pre>

<!-------------------------------     STEP 2      --------------------------->
<!--  Include download and sample image information.                       --> 

<ul class=download>
	<li><a href="MVVM_Dialogs.zip">Download source - ?.?? MB</a></li>
</ul>

<p><img src="Application.png" alt="Screenshot of application" width=302 height=302></p>


<!-------------------------------     STEP 3      --------------------------->

<h2>
	Contents</h2>

<ul>
	<li><a href="#intro">Introduction</a></li>
	<li><a href="#my_mvvm">My Interpretation of MVVM</a></li>
	<li><a href="#dialog_service">The Dialog Service</a></li>
</ul>

<h2>
	<a name="intro">Introduction</a>
</h2>

<p>This article will address one of the problems a developer might run into when using the
	MVVM pattern, namely opening dialogs from ViewModels. Basic knowleadge of the pattern is expected. Josh Smith has written a fantastic
	<a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">article</a>
	in MSDN Magazine which can serve as starting point for those that are unfamiliar with the pattern.</p>
	
<p>There already 
		exists some solutions exploring this area, but none of them seems to be widely 
		accepted among the MVVM community. <a href="http://wpfonyx.codeplex.com/">Onyx</a> on CodePlex 
		is one solution, but requires the developer to connect ViewModel and View at compile time using attached properties.
		Onyx also handles dependency injection to the ViewModel, something one already might have a solution for.
		Sacha Barber <a href="http://sachabarber.net/?p=518">announced</a> that 
		he is working on a new MVVM framework, but hasn&#39;t set any release date.</p>

<h2>
	<a name="my_mvvm">My Interpretation of MVVM</a>
</h2>

<p>I am possibly sticking my neck out here, but I would like to state some of my 
	own interpretations of the MVVM pattern:</p>

<ul>
<li>The fundamental core is separation of UI and logic. ViewModel and View 
	can communicate using bindings, making it possible for the View to be happily 
	unaware of the ViewModel and vica versa. I know some of you might say: <i>&quot;well, 
	actually the View knows about the ViewModel since the ViewModel is stored within 
	the DataContext property, and the View is declaring it&#39;s bindings to match 
	properties on the ViewModel, surely the View must know the ViewModel!&quot;</i>. I 
	don&#39;t think so, we have to analyse what <i>knows</i> actually means. The 
	ViewModel is stored in the DataContext property, that is correct, but 
	DataContext is of type <code>Object</code>. From the View&#39;s point, the only thing it knows is 
	whether the property has been set or not, nothing about the actual content. Lets 
	get to the bindings that are declared in the View, do they say something about 
	the ViewModel? I would have to say no here as well. The View might declare 
	whatever bindings it wishes, but the ViewModel isn&#39;t enforced to implement them, 
	it is declared using a interface. </li>
	<li></li>
	<li></li>
	<li></li>
	<li>&nbsp;of the View. To me that is a definition How well these two are separated 
		. It is however more 
		uncertain whether a view may know its ViewModel, or reverse the ViewModel 
		knowing the view. I perhaps have to explain my definition of <i>know</i> and the different 
		guidelines I try to live by when coding MVVM.</li>

<li>Know in my universe means 
		holding a reference to a class, and know without reflection or casting the true 
		nature of the class. A view will always hold a reference to the ViewModel since 
		the ViewModel is stored within the DataContext property, but that is not <i>
		knowing</i>. The view has no idea of how to interact with the ViewModel since 
		DataContect is typed to Object. One might argue that the view has knowleadge of 
		the ViewModel since it binds XAML to properties exposed by ViewModel, but I 
		don&#39;t call this knowing eather. The view will surely miss data in the view if a 
		binding fails, but the WPF framework is designed to ignore failed binding and 
		the view will present itself regardless of whether the ViewModel provides all 
		properties declared int the UI.</li>
	<li>It would be nice if the ViewModel would be 
		happily unaware of the view. The ViewModel should serve the view with data, but 
		one might argue where the separation between view and ViewModel is. If for 
		instance the ViewModel is holding a list of items presented in a ListView, I 
		would argue that sorting, grouping and filtering could be the responsibity of 
		the view, not the ViewModel. Attached properties can solve this for us, making 
		the ViewModel happily unaware of the item formatting.</li>

	<li>Keeping logic in the ViewModel allows for good test coverage. The ViewModel 
		should not contain anything used purely in tests, either a class is testable or 
		it isn&#39;t.</li>
</ul>

<h2>
	<a name="dialog_service">The Dialog Service</a>
</h2>

<p>The concept of letting services handle relations between ViewModel and View 
	seems to be the most accepted solution. My contribution is <code>IDialogService</code>, 
	a interface that currently only holds two interesting methods. <code>ShowDialog</code> will 
	open any <code>Window</code> as a dialog and <code>ShowMessageBox</code> will open a <code>MessageBox</code>.</p>

<pre lang="cs">
public interface IDialogService
{
  /// &lt;summary>
  /// Registers a view.
  /// &lt;/summary>
  /// &lt;param name="view">The registered view.&lt;/param>
  void Register(FrameworkElement view);

  /// &lt;summary>
  /// Unregisters a view.
  /// &lt;/summary>
  /// &lt;param name="view">The unregistered view.&lt;/param>
  void Unregister(FrameworkElement view);

  /// &lt;summary>
  /// Shows a dialog.
  /// &lt;/summary>
  /// &lt;param name="ownerViewModel">A ViewModel that represents the owner window of
  /// the dialog.&lt;/param>
  /// &lt;param name="viewModel">The ViewModel of the new dialog.&lt;/param>
  /// &lt;returns>A nullable value of type bool that signifies how a window was closed
  /// by the user.&lt;/returns>
  bool? ShowDialog&lt;T>(object ownerViewModel, object viewModel) where T : Window;

  /// &lt;summary>
  /// Shows a message box.
  /// &lt;/summary>
  /// &lt;param name="ownerViewModel">A ViewModel that represents the owner window of
  /// the message box.&lt;/param>
  /// &lt;param name="messageBoxText">A string that specifies the text to display.&lt;/param>
  /// &lt;param name="caption">A string that specifies the title bar caption to display.&lt;/param>
  /// &lt;param name="button">A MessageBoxButton value that specifies which button or buttons
  /// to display.&lt;/param>
  /// &lt;param name="icon">A MessageBoxImage value that specifies the icon to display.&lt;/param>
  /// &lt;returns>A MessageBoxResult value that specifies which message box button is clicked
  /// by the user.&lt;/returns>
  MessageBoxResult ShowMessageBox(object ownerViewModel, string messageBoxText, string caption,
    MessageBoxButton button, MessageBoxImage icon);
}
</pre>

<p>
	The actual implementation of <code>IDialogServiceis</code> is <code>DialogService</code>.</p>

<pre lang="cs">
public class DialogService : IDialogService
{
  private static IDialogService instance;
  private HashSet&lt;FrameworkElement> views;

  /// &lt;summary>
  /// The Singleton instance of this class.
  /// &lt;/summary>
  public static IDialogService Instance
  {
    get
    {
      if (instance == null)
      {
        instance = new DialogService();
      }
      return instance;
    }
  }

  private DialogService()
  {
    views = new HashSet&lt;FrameworkElement>();
  }

  #region IDialogService Members

  /// &lt;summary>
  /// Registers a view.
  /// &lt;/summary>
  /// &lt;param name="view">The registered view.&lt;/param>
  public void Register(FrameworkElement view)
  {
    if (views.Contains(view)) throw new ArgumentException("View has already been registered.");

    // Get owner window
    Window owner = view as Window;
    if (owner == null)
    {
      owner = Window.GetWindow(view);
    }
						
    if (owner == null)
    {
      throw new InvalidOperationException("View is not contained within a Window.");
    }

    // Register for owner window closing, since we then should unregister view reference,
    // preventing memory leaks
    owner.Closed += OwnerClosed;

    views.Add(view);
  }

  /// &lt;summary>
  /// Unregisters a view.
  /// &lt;/summary>
  /// &lt;param name="view">The unregistered view.&lt;/param>
  public void Unregister(FrameworkElement view)
  {
    if (!views.Contains(view)) throw new ArgumentException("View has never been registered.");

    views.Remove(view);
  }

  /// &lt;summary>
  /// Shows a dialog.
  /// &lt;/summary>
  /// &lt;param name="ownerViewModel">A ViewModel that represents the owner window of
  /// the dialog.&lt;/param>
  /// &lt;param name="viewModel">The ViewModel of the new dialog.&lt;/param>
  /// <returns>A nullable value of type bool that signifies how a window was closed
  /// by the user.&lt;/returns>
  public bool? ShowDialog&lt;T>(object ownerViewModel, object viewModel) where T : Window
  {
    // Create dialog and set properties
    T dialog = Activator.CreateInstance<T>();
    dialog.Owner = FindOwnerWindow(ownerViewModel);
    dialog.DataContext = viewModel;

    // Show dialog
    return dialog.ShowDialog();
  }

  /// &lt;summary>
  /// Shows a message box.
  /// &lt;/summary>
  /// &lt;param name="ownerViewModel">A ViewModel that represents the owner window of
  /// the message box.&lt;/param>
  /// &lt;param name="messageBoxText">A string that specifies the text to display.&lt;/param>
  /// &lt;param name="caption">A string that specifies the title bar caption to display.&lt;/param>
  /// &lt;param name="button">A MessageBoxButton value that specifies which button or buttons
  /// to display.&lt;/param>
  /// &lt;param name="icon">A MessageBoxImage value that specifies the icon to display.&lt;/param>
  /// &lt;returns>A MessageBoxResult value that specifies which message box button is clicked
  /// by the user.&lt;/returns>
  public MessageBoxResult ShowMessageBox(object ownerViewModel, string messageBoxText, string caption,
    MessageBoxButton button, MessageBoxImage icon)
  {
    return MessageBox.Show(FindOwnerWindow(ownerViewModel), messageBoxText, caption, button, icon);
  }

  #endregion

  #region Attached properties

  /// &lt;summary>
  /// Attached property describing whether a FrameworkElement is acting as a view in MVVM.
  /// &lt;/summary>
  public static readonly DependencyProperty IsRegisteredViewProperty = DependencyProperty.RegisterAttached(
    "IsRegisteredView",
    typeof(bool),
    typeof(DialogService),
    new UIPropertyMetadata(IsRegisteredViewPropertyChanged));

  /// &lt;summary>
  /// Gets value describing whether FrameworkElement is acting as view in MVVM.
  /// &lt;/summary>
  public static bool GetIsRegisteredView(FrameworkElement target)
  {
    return (bool)target.GetValue(IsRegisteredViewProperty);
  }

  /// &lt;summary>
  /// Sets value describing whether FrameworkElement is acting as view in MVVM.
  /// &lt;/summary>
  public static void SetIsRegisteredView(FrameworkElement target, bool value)
  {
    target.SetValue(IsRegisteredViewProperty, value);
  }

  /// &lt;summary>
  /// Is responsible for handling IsRegisteredViewProperty changes, i.e. whether
  /// FrameworkElement is acting as view in MVVM or not.
  /// &lt;/summary>
  private static void IsRegisteredViewPropertyChanged(DependencyObject target,
    DependencyPropertyChangedEventArgs e)
  {
    FrameworkElement view = target as FrameworkElement;
    if (view != null)
    {
      // Cast values
      bool newValue = (bool)e.NewValue;
      bool oldValue = (bool)e.OldValue;

      if (newValue)
      {
        Instance.Register(view);
      }
      else
      {
        Instance.Unregister(view);
      }
    }
  }

  #endregion

  /// &lt;summary>
  /// Finds window corresponding to specified ViewModel.
  /// &lt;/summary>
  private Window FindOwnerWindow(object viewModel)
  {
    FrameworkElement view = views.SingleOrDefault(v => ReferenceEquals(v.DataContext, viewModel));
    if (view == null)
    {
      throw new ArgumentException("ViewModel is not referenced by any registered view.");
    }

    // Get owner window
    Window owner = view as Window;
    if (owner == null)
    {
      owner = Window.GetWindow(view);
    }

    // Make sure owner window was found
    if (owner == null)
    {
      throw new InvalidOperationException("View is not contained within a Window.");
    }

    return owner;
  }


  /// &lt;summary>
  /// Handles owner window closed, view service should then unregister all views acting
  /// within the closed window.
  /// &lt;/summary>
  private void OwnerClosed(object sender, EventArgs e)
  {
    Window owner = sender as Window;
    if (owner != null)
    {
      // Find views acting within closed window
      IEnumerable&lt;FrameworkElement> windowViews =
        from view in views
        where Window.GetWindow(view) == owner
        select view;

      // Unregister views in window
      foreach (FrameworkElement view in windowViews.ToArray())
      {
        Unregister(view);
      }
    }
  }
}
</pre>

<p>The design is pretty straight forward. A view is registering itself as part of 
	the MVVM pattern by setting the attached property <code>IsRegisteredView</code> 
	on any element in the logical tree.</p>
	
<pre lang="xml">
&lt;Window
  x:Class="MVVM_Dialogs.View.MainWindow"
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
  xmlns:Service="clr-namespace:MVVM_Dialogs.Service"
  Service:DialogService.IsRegisteredView="True">
</pre>

<p>The view is then remembered by the dialog service, and when a ViewModel is 
	requesting to show some kind of dialog, the view with specified owner ViewModel 
	if found, thus providing the owner of the new dialog.</p>

<!-------------------------------    That's it!   --------------------------->
</body>

</html>
